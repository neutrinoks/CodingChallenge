//! Data type definitions which are generated by the parser.

/// Not all values (e.g. objects and arrays) can be depicted from the beginning. Therefore a
/// partial-value for the first stage of parsing is needed and to be included to build higher level
/// values like objects and arrays.
#[derive(Clone, Debug, PartialEq)]
pub enum JPartialValue {
    Float(f64),
    Integer(isize),
    String(String),
    True,
    False,
    Null,
}

impl From<bool> for JPartialValue {
    fn from(b: bool) -> JPartialValue {
        if b {
            JPartialValue::True
        } else {
            JPartialValue::False
        }
    }
}

impl From<isize> for JPartialValue {
    fn from(i: isize) -> JPartialValue {
        JPartialValue::Integer(i)
    }
}

impl From<f64> for JPartialValue {
    fn from(f: f64) -> JPartialValue {
        JPartialValue::Float(f)
    }
}

impl From<&str> for JPartialValue {
    fn from(s: &str) -> JPartialValue {
        JPartialValue::String(String::from(s))
    }
}

/// Definition for one name-value-keypair of a json-object (including the main object).
#[derive(Debug, Clone)]
pub struct JMember {
    pub name: String,
    pub value: JValue,
}

impl JMember {
    pub(crate) fn from_keypair<P>(name: &str, value: P) -> JMember 
    where P: Into<JValue>
    {
        JMember{ name: name.to_string(), value: value.into() }
    }
}

#[derive(Debug, Clone)]
pub struct JObject {
    /// The object's name.
    pub name: String,
    /// The object's members.
    pub member: Vec<JMember>,
}

/// Value type of the JSON syntax.
#[derive(Debug, Clone)]
pub enum JValue {
    Object(JObject),
    Array(Vec<JPartialValue>),
    Value(JPartialValue),
}

impl From<bool> for JValue {
    fn from(b: bool) -> JValue {
        JValue::Value(JPartialValue::from(b))
    }
}

impl From<isize> for JValue {
    fn from(i: isize) -> JValue {
        JValue::Value(JPartialValue::from(i))
    }
}

impl From<f64> for JValue {
    fn from(f: f64) -> JValue {
        JValue::Value(JPartialValue::from(f))
    }
}

impl From<&str> for JValue {
    fn from(s: &str) -> JValue {
        JValue::Value(JPartialValue::from(s))
    }
}
