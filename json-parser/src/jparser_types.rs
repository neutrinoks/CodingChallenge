//! Data type definitions which are generated by the parser.

/// Not all values (e.g. objects and arrays) can be depicted from the beginning. Therefore a
/// partial-value for the first stage of parsing is needed and to be included to build higher level
/// values like objects and arrays.
#[derive(Clone, Debug, PartialEq)]
pub enum JPartialValue {
    Float(f64),
    Integer(isize),
    String(String),
    True,
    False,
    Null,
}

impl From<bool> for JPartialValue {
    fn from(b: bool) -> JPartialValue {
        if b {
            JPartialValue::True
        } else {
            JPartialValue::False
        }
    }
}

impl From<isize> for JPartialValue {
    fn from(i: isize) -> JPartialValue {
        JPartialValue::Integer(i)
    }
}

impl From<f64> for JPartialValue {
    fn from(f: f64) -> JPartialValue {
        JPartialValue::Float(f)
    }
}

impl From<&str> for JPartialValue {
    fn from(s: &str) -> JPartialValue {
        JPartialValue::String(String::from(s))
    }
}

/// Definition for one name-value-keypair of a json-object (including the main object).
#[derive(Debug, Clone, PartialEq)]
pub struct JMember {
    pub name: String,
    pub value: JValue,
}

#[derive(Debug, Clone, PartialEq)]
pub struct JObject {
    /// The object's members.
    pub members: Vec<JMember>,
}

impl JObject {
    /// New type pattern.
    pub fn new() -> JObject {
        JObject {
            members: Vec::new(),
        }
    }
}

/// Value type of the JSON syntax.
#[derive(Debug, Clone, PartialEq)]
pub enum JValue {
    Object(JObject),
    Array(Vec<JPartialValue>),
    Value(JPartialValue),
}

impl From<JPartialValue> for JValue {
    fn from(val: JPartialValue) -> JValue {
        JValue::Value(val)
    }
}

impl From<bool> for JValue {
    fn from(b: bool) -> JValue {
        JValue::Value(JPartialValue::from(b))
    }
}

impl From<isize> for JValue {
    fn from(i: isize) -> JValue {
        JValue::Value(JPartialValue::from(i))
    }
}

impl From<f64> for JValue {
    fn from(f: f64) -> JValue {
        JValue::Value(JPartialValue::from(f))
    }
}

impl From<&str> for JValue {
    fn from(s: &str) -> JValue {
        JValue::Value(JPartialValue::from(s))
    }
}

#[macro_export]
macro_rules! jobject {
    ($($name:expr, $val:expr),*) => {
        {
            let mut object = JObject::new();
            $(
                object.members.push(JMember{ name: $name.into(), value: $val });
            )*
            object
        }
    }
}
